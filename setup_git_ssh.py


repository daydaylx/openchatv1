#!/usr/bin/env python3
"""
setup_git_ssh.py

Automatisiert im aktuellen Verzeichnis:
 * SSH-Key-Erzeugung (ed25519) falls nicht vorhanden
 * Ausgabe des Public-Keys zum Kopieren nach GitHub
 * Git-Init, Remote-Setup, Commit, Push
"""

import os
import subprocess
import logging
import sys
from pathlib import Path

# === Konfiguration ===
SSH_KEY_PATH = Path.home() / ".ssh" / "id_ed25519"
GIT_REMOTE_URL = "git@github.com:daydaylx/openchatv1.git"
DEFAULT_BRANCH = "main"

# === Logging einrichten ===
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(levelname)s â”‚ %(message)s",
    datefmt="%H:%M:%S"
)
log = logging.getLogger(__name__)

def run(cmd, **kwargs):
    """Hilfsfunktion fÃ¼r subprocess.run mit FehlerprÃ¼fung."""
    log.debug(f"Running: {' '.join(cmd)}")
    res = subprocess.run(cmd, text=True, capture_output=True, **kwargs)
    if res.returncode != 0:
        log.error(f"Command failed: {' '.join(cmd)}\n"
                  f"â†’ stdout: {res.stdout.strip()}\n"
                  f"â†’ stderr: {res.stderr.strip()}")
        sys.exit(1)
    return res.stdout.strip()

def ensure_ssh_key():
    if SSH_KEY_PATH.exists() and SSH_KEY_PATH.with_suffix(".pub").exists():
        log.info("SSH-Key bereits vorhanden.")
    else:
        log.info("SSH-Key nicht gefunden. Erzeuge neuen ed25519-Keyâ€¦")
        run(["ssh-keygen", "-t", "ed25519", "-C", f"{os.getlogin()}@{os.uname().nodename}", "-f", str(SSH_KEY_PATH), "-N", ""])
        log.info("Neuer SSH-Key erzeugt.")

    pub = SSH_KEY_PATH.with_suffix(".pub").read_text().strip()
    log.info("ðŸ”‘ Dein Public-Key:")
    print("\n" + pub + "\n")
    log.info("ðŸ‘‰ Bitte kopiere den obigen Key und fÃ¼ge ihn in GitHub unter â€šSettings â†’ SSH and GPG keysâ€˜ hinzu.")
    input("DrÃ¼cke Enter, wenn du den Key eingetragen hastâ€¦")

def git_init_and_remote():
    cwd = Path.cwd()
    if not (cwd / ".git").exists():
        log.info("Initialisiere Git-Repoâ€¦")
        run(["git", "init"])
    else:
        log.info("Git-Repo schon initialisiert.")

    # Remote entfernen, falls schon vorhanden
    existing = run(["git", "remote"], check=False)
    if "origin" in existing.splitlines():
        log.info("Entferne alten 'origin'-Remoteâ€¦")
        run(["git", "remote", "remove", "origin"], check=False)

    log.info(f"FÃ¼ge Remote '{GIT_REMOTE_URL}' hinzuâ€¦")
    run(["git", "remote", "add", "origin", GIT_REMOTE_URL])

def commit_and_push():
    # Stage alle Dateien
    log.info("Stage alle Dateien fÃ¼r Commitâ€¦")
    run(["git", "add", "."])

    # Commit erstellen, wenn noch kein HEAD existiert
    head = subprocess.run(["git", "rev-parse", "--verify", "HEAD"], capture_output=True)
    if head.returncode != 0:
        log.info("Erstelle ersten Commitâ€¦")
        run(["git", "commit", "-m", "Initial commit"])
    else:
        log.info("Commit(s) existieren bereits â€“ Ã¼berspringe ersten Commit.")

    # Push
    log.info(f"Push auf Branch '{DEFAULT_BRANCH}' und setze Trackingâ€¦")
    run(["git", "push", "-u", "origin", DEFAULT_BRANCH])

def main():
    log.info("=== Starte Git-SSH-Setup im aktuellen Ordner ===")
    ensure_ssh_key()
    git_init_and_remote()
    commit_and_push()
    log.info("âœ… Fertig! Ab jetzt laufen alle Pulls/Pushes per SSH ohne Passwort-Prompt.")

if __name__ == "__main__":
    main()

